2 - 1
题目内容是：线性表若采用链式存储结构时，要求内存中可用存储单元的地址。选项有四个：
A. 必须是连续的
B. 连续或不连续都可以
C. 部分地址必须是连续的
D. 一定是不连续的
在链式存储结构中，数据元素的存储单元可以是不连续的，通过指针将各个元素连接起来。所以这道题的答案是 D. 一定是不连续的。
这种存储方式与顺序存储结构不同，顺序存储结构要求存储单元是连续的。链式存储结构的优点是便于插入和删除操作，不需要移动大量元素。

2 - 2，分值为 2 分。
题目内容是：在具有 N 个结点的单链表中，实现下列哪个操作，其算法的时间复杂度是 O (N)？选项有四个：
A. 在地址为 p 的结点之后插入一个结点
B. 删除开始结点
C. 遍历链表和求链表的第 i 个结点
D. 删除地址为 p 的结点的后继结点
对于选项 A：
在单链表中，在地址为 p 的结点之后插入一个结点，只需要找到 p 结点，然后进行插入操作，时间复杂度是 O (1)，因为插入操作只涉及到修改几个指针。
对于选项 B：
删除开始结点，只需要修改头指针，时间复杂度是 O (1)。
对于选项 C：
遍历链表和求链表的第 i 个结点，在最坏情况下，需要遍历整个链表，时间复杂度是 O (N)。因为单链表只能从头开始依次访问每个结点，当求第 i 个结点（i 接近 N）时，需要遍历接近 N 个结点。
对于选项 D：
删除地址为 p 的结点的后继结点，只需要找到 p 结点，然后修改指针，时间复杂度是 O (1)。
因此，正确答案是 C。

2 - 3，分值为 2 分。
题目是：线性表 L 在什么情况下适用于使用链式结构实现？选项有：
A. 需不断对 L 进行删除插入
B. 需经常修改 L 中的结点值
C. L 中含有大量的结点
D. L 中结点结构复杂
解析如下：
对于选项 A：
链式存储结构在进行插入和删除操作时，只需要修改指针的指向，不需要移动大量的数据元素，时间复杂度为 O (1)（在找到操作位置后），所以当需要不断对线性表进行删除插入操作时，适合采用链式结构。
对于选项 B：
如果只是经常修改结点值，顺序存储结构和链式存储结构在修改值操作上的复杂度类似，但链式结构在空间上可能会有额外的指针开销，所以经常修改结点值不是选择链式结构的主要原因。
对于选项 C：
线性表中含有大量结点本身并不决定要使用链式结构。如果操作主要是随机访问，顺序存储结构可能更合适，因为链式结构在随机访问时需要遍历链表，效率较低。
对于选项 D：
结点结构复杂不是决定使用链式结构的关键因素，链式结构和结点结构复杂与否没有必然联系。
正确答案是 A。

2 - 4，分值为 2 分。
题目是：链表不具有的特点是：
A. 插入、删除不需要移动元素
B. 方便随机访问任一元素
C. 不必事先估计存储空间
D. 所需空间与线性长度成正比
解析如下：
对于选项 A：
链表在插入和删除操作时，只需要修改指针的指向，不需要移动元素，这是链表的优点，所以 A 选项不符合题意。
对于选项 B：
链表不能像顺序表那样通过下标直接随机访问元素，要访问链表中的某个元素，需要从表头开始依次遍历，所以链表不具有方便随机访问任一元素这个特点，B 选项符合题意。
对于选项 C：
链表的存储空间是动态分配的，不需要事先估计存储空间，这是链表的优点，所以 C 选项不符合题意。
对于选项 D：
链表中每个节点都需要额外的空间存储指针，其所需空间与线性长度成正比，这是链表的特点，所以 D 选项不符合题意。
正确答案是 B。

2 - 5，分值为 2 分。
题目内容是：在单链表中，要删除某一指定结点，必须先找到该结点的（）。选项有四个：
A. 直接前驱
B. 自身位置
C. 直接后继
D. 直接后继的后继
解析如下：
在单链表中删除一个指定结点，需要修改该结点前驱结点的指针，使其指向该结点的后继结点。所以必须先找到该结点的直接前驱。
找到自身位置（选项 B）并不能完成删除操作，因为单链表无法直接修改前一个结点指向。
找到直接后继（选项 C）或直接后继的后继（选项 D）都不能帮助完成删除操作，关键是要找到其直接前驱来修改指针。
正确答案是 A。

2 - 6
题目：以下关于链式存储结构的叙述中，（）是不正确的。
选项：
A. 结点除自身信息外还包括指针域，因此存储密度小于顺序存储结构
B. 逻辑上相邻的结点物理上不必邻接
C. 可以通过计算直接确定第 i 个结点的存储地址
D. 插入、删除运算操作方便，不必移动结点
解析：
A 选项：链式存储结构的每个节点除了存储数据本身外，还需要存储指针，而顺序存储结构只存储数据元素，所以链式存储结构的存储密度小于顺序存储结构，A 正确。
B 选项：链式存储结构中，逻辑上相邻的节点通过指针相连，物理上不一定相邻，B 正确。
C 选项：在链式存储结构中，由于节点的存储位置是不连续的，不能通过计算直接得到第 i 个节点的存储地址，而在顺序存储结构中可以，C 错误。
D 选项：链式存储结构在插入和删除操作时，只需要修改指针的指向，不需要移动节点，D 正确。
答案：C

2 - 7
题目：对于一个具有 N 个结点的单链表，在给定值为 x 的结点后插入一个新结点的时间复杂度为
选项：
A. O (1)
B. O (N/2)
C. O (N)
D. O (N²)
解析：
首先要在单链表中找到值为 x 的结点，在最坏的情况下，需要遍历整个链表，时间复杂度为 O (N)，找到之后插入新结点只需要修改指针，时间复杂度为 O (1)，总体时间复杂度取决于查找的过程，即 O (N)。
答案：C

2 - 8
题目：链表的存储密度____。
选项：
A. 大于 1
B. 等于 1
C. 小于 1
D. 不能确定
解析：
存储密度 = 数据元素所占存储空间 / 整个结点所占存储空间。由于链表的结点除了数据元素还包含指针域，所以存储密度小于 1。
答案：C

2 - 9
题目：在数据结构中，从逻辑上可以把数据结构分成（）。
选项：
A. 动态结构和静态结构
B. 紧凑结构和非紧凑结构
C. 线性结构和非线性结构
D. 内部结构和外部结构
解析：
从逻辑上数据结构可以分为线性结构和非线性结构。线性结构有顺序表、链表等，非线性结构有树、图等。
答案：C

2 - 10
题目：以下说法正确的是（）。
选项：
A. 数据元素是数据的最小单位
B. 数据项是数据的基本单位
C. 数据结构是带有结构的各数据项的集合
D. 一些表面上很不相同的数据可以有相同的逻辑结构
解析：
A 选项：数据项是数据的最小单位，而不是数据元素，A 错误。
B 选项：数据元素是数据的基本单位，而不是数据项，B 错误。
C 选项：数据结构是带有结构的各数据元素的集合，而不是数据项，C 错误。
D 选项：不同的数据可以有相同的逻辑结构，例如栈这种逻辑结构可以应用于很多不同的数据场景，D 正确。
答案：D

2 - 11
题目：与数据元素本身的形式、内容、相对位置、个数无关的是数据的（）。
选项：
A. 存储结构
B. 存储实现
C. 逻辑结构
D. 运算实现
解析：
逻辑结构是从数据元素的逻辑关系上描述数据，与数据元素本身的具体形式、内容、相对位置、个数无关。
A 选项：存储结构与数据元素在计算机中的存储方式有关，A 不符合。
B 选项：存储实现侧重于如何在存储介质上实现存储结构，B 不符合。
D 选项：运算实现涉及对数据进行操作的具体实现，D 不符合。
答案：C

2 - 12
题目：以下数据结构中，（）是非线性数据结构。
选项：
A. 树
B. 字符串
C. 队列
D. 栈
解析：
非线性数据结构是指数据元素之间存在一对多或者多对多的关系。树是典型的非线性数据结构，因为一个节点可以有多个子节点。
B 选项：字符串可以看成是字符的线性序列，属于线性结构，B 不符合。
C 选项：队列是一种先进先出的线性表，属于线性结构，C 不符合。
D 选项：栈是一种后进先出的线性表，属于线性结构，D 不符合。
答案：A

2 - 13
题目：假设某个带头结点的单链表的头指针为 head，则判定该表为空表的条件是（）
选项：
A. head==None
B. head.next==None
C. head!=None
D. head.next==head
解析：
在带头结点的单链表中，头指针 head 始终指向头结点。当链表为空时，头结点的 next 指针指向 None。
A 选项：head==None 表示头指针不存在，这不符合带头结点单链表的定义，A 错误。
C 选项：head!=None 只能说明头指针存在，但不能判断链表是否为空，C 错误。
D 选项：head.next==head 这种情况不是空表的判断条件，D 错误。
答案：B

2 - 14
题目：单链表的结点指针域为 next，其头结点由指针 head 指向，则删除第一个数据结点（由指针 p 指向）的语句为（）
选项：
A. p.next = head.next
B. head.next = p
C. p = head.next
D. head.next = p.next
解析：
要删除第一个数据结点（由指针 p 指向），只需要让头结点的 next 指针指向 p 的下一个结点，即 head.next = p.next。
A 选项：p.next = head.next 没有实现删除 p 结点的目的，A 错误。
B 选项：head.next = p 会导致链表错误，B 错误。
C 选项：p = head.next 只是重新赋值指针 p，没有删除操作，C 错误。
答案：D

2 - 15
题目：单链表的指针域为 next，其头结点由指针 head 指向，则把指针 p 指向的结点链接到头结点之后的语句序列为（）
选项：
A. p.next=head.next; head.next=p
B. head=p; p.next=head.next;
C. head.next = p.next; p= head.next
D. p.next=head; head=p
解析：
要把指针 p 指向的结点链接到头结点之后，首先让 p 的 next 指针指向原来头结点的下一个结点，即 p.next = head.next，然后让头结点的 next 指针指向 p，即 head.next = p。
B 选项：head=p 会丢失原来的头结点，B 错误。
C 选项：head.next = p.next 会丢失原来头结点的下一个结点，C 错误。
D 选项：p.next=head 和 head=p 的操作顺序和逻辑都不正确，D 错误。
答案：A

2 - 16
题目：不带头结点的单链表（头指针为 head）为空的判定条件是（）
选项：
A. head==None
B. head.next==None
C. head.next==head
D. head!=None
解析：
对于不带头结点的单链表，当链表为空时，头指针本身应该为 None。如果头指针不为 None，说明链表中有节点存在。
B 选项 head.next==None 适用于带头结点的单链表判断空表的情况。
C 选项 head.next==head 不符合单链表空表的判断逻辑。
D 选项 head!=None 表示链表不为空。
答案：A

2 - 17
题目：带头结点的循环单链表（头指针为 head）为空的判定条件是（）
选项：
A. head==None
B. head.next==None
C. head.next==head
D. head!=None
解析：
在带头结点的循环单链表中，当链表为空时，头结点的 next 指针指向自己，即 head.next == head。
A 选项 head==None 不符合带头结点的链表定义。
B 选项 head.next==None 表示只有头结点且没有其他节点，但不是循环单链表空表的判断条件。
D 选项 head!=None 不能说明链表是否为空。
答案：C

2 - 18
题目：在单链表中，指针域为 next，要将 q 所指结点链接到 p 所指结点之后，其语句序列应为（）
选项：
A. q.next=p.next; p.next=q
B. p.next=q; q.next=p.next
C. q.next=p + 1; p.next=q
D. p.next=q; q.next=p
解析：
要将 q 所指结点链接到 p 所指结点之后，首先要让 q 的 next 指针指向 p 的下一个结点，即 q.next = p.next，然后再让 p 的 next 指针指向 q，即 p.next = q。
B 选项中 q.next=p.next 在 p.next 已经改变后执行是错误的顺序。
C 选项 q.next=p + 1 不符合单链表的操作逻辑。
D 选项 q.next=p 会导致错误的链表结构。
答案：A

2 - 19
题目：在双向链表中，前驱指针为 prior，后继指针为 next，在 p 指针所指的结点后插入 q 所指的新结点，其语句序列是（）
选项：
A. q.prior=p; q.next=p.next; p.next=q; p.next.prior=q
B. q.prior=p; q.next=p.next; p.next.prior=q; p.next=q
C. p.next=q; p.next.prior=q; q.prior=p; q.next=p.next
D. p.next=q; q.prior=p; p.next.prior=q; q.next=q
解析：
在双向链表中插入节点，首先要处理新节点 q 与周围节点的指针关系。先让 q 的前驱指针指向 p，即 q.prior = p，然后让 q 的后继指针指向 p 的下一个节点，即 q.next = p.next，接着修改 p 的下一个节点的前驱指针指向 q，即 p.next.prior = q，最后让 p 的后继指针指向 q，即 p.next = q。
A 选项中 p.next=q 应该最后执行。
C 选项顺序有误，会导致指针错误。
D 选项存在类似顺序错误和指针错误。
答案：B

2 - 20
题目：在双向链表中，前驱指针为 prior，后继指针为 next，删除 p 所指的结点的语句序列为（）
选项：
A. p.prior.next=p; p.prior=p.prior.prior
B. p.prior=p.next.next; p.next=p.prior.prior
C. p.next.prior=p.prior; p.prior.next=p.next
D. p.next=p.next.next; p.next.prior=p
解析：
要删除双向链表中的 p 节点，需要将 p 的前驱节点的后继指针指向 p 的后继节点，即 p.next.prior = p.prior，同时将 p 的后继节点的前驱指针指向 p 的前驱节点，即 p.prior.next = p.next。
A 选项操作顺序和逻辑错误。
B 选项操作不符合双向链表删除节点的逻辑。
D 选项操作不完整且存在逻辑错误。
答案：C

2 - 21
题目：现有非空双向链表 L，其结构为 prev、data、next，prev 是指向直接前驱结点的指针，next 是指向直接后继结点的指针。若要在 L 中 p 所指向的结点（非尾结点）之后插入指针 s 指向的新结点，则在执行了语句序列 p->next = s; s->prev = p; 后，下列语句序列中还需要执行的是：
选项：
A. s->next->prev = s; s->prev = p;
B. p->next->prev = s; s->prev = p;
C. s->prev = s->next->prev; s->next->prev = s;
D. p->next->prev = s; s->next->prev = p;
解析：
首先执行了 p->next = s; s->prev = p; 这两步操作。
接下来还需要处理 s 结点的后继指针和 s 的后继结点的前驱指针。
应该让 s 的后继结点（原来 p 的后继结点）的前驱指针指向 s，即 p->next->prev = s;
同时让 s 的后继指针指向原来 p 的后继结点，即 s->next = p->next;
答案：B

2 - 22
题目：已知带头结点的非空单链表 L 的头指针为 h，结点结构为 data、next，其中 next 是指向直接后继结点的指针。现有指针 p 和 q，若 p 指向 L 中非头且非尾的任意一个结点，则执行语句序列 q->next = p->next; p->next = q; 的结果是
选项：
A. 在 p 所指结点后插入 q 所指结点
B. 在 q 所指结点后插入 p 所指结点
C. 将 q 所指结点移动到 L 的头结点之后
D. 将 p 所指结点移动到 L 的头结点之后
解析：
执行 q->next = p->next; 这一步操作，使得 q 的下一个结点指向原来 p 的下一个结点。
然后执行 p->next = q; 这一步操作，使得 p 的下一个结点指向 q。
这两步操作的结果是在 p 所指结点后插入 q 所指结点。
答案：A

2 - 23
题目：线性表 L=(a1, a2, …, an)，下列说法正确的是 ()
选项：
A. 每个元素都有一个直接前驱和一个直接后继
B. 表中至少有一个元素
C. 表中元素需有序
D. 除第一个和最后一个元素外，其他元素都有且仅有一个直接前驱和一个直接后继
解析：
线性表的定义：线性表是 n 个数据元素的有限序列 (n≥0)。
A 选项：当线性表为空时，没有元素，不存在前驱和后继，当只有一个元素时，只有一个元素没有前驱和后继，A 错误。
B 选项：线性表可以为空表，即 n = 0，B 错误。
C 选项：线性表中的元素是有顺序的，C 正确。
D 选项：解释同 A 选项，当线性表为空或只有一个元素时不成立，D 错误。
答案：C

2 - 24
题目：线性表 (a1, a2, …, an) 以顺序存储结构存储时，访问第 i 位置元素的时间复杂度为 ()
选项：
A. O (1)
B. O (n)
C. O (i)
D. O (i - 1)
解析：
在顺序存储结构中，元素是按顺序依次存储在连续的存储单元中的。
要访问第 i 个位置的元素，只需要通过首地址加上偏移量 (i - 1)× 元素大小就可以直接定位到该元素，不需要遍历其他元素。
所以时间复杂度为 O (1)。
答案：A

2 - 25
题目：顺序表中第 1 个元素的存储地址是 2000，每个元素的长度为 4，则第 5 个元素的地址是 ()
选项：
A. 2020
B. 2016
C. 2024
D. 2012
解析：
已知第 1 个元素存储地址为 2000，每个元素长度为 4。
第 5 个元素与第 1 个元素相隔 4 个位置（5 - 1 = 4）。
所以第 5 个元素的地址为 2000+(5 - 1)×4 = 2000 + 16 = 2016。
答案：B

2 - 26
题目：下列对顺序存储的有序表（长度为 n）实现给定操作的算法中，平均时间复杂度为 O (1) 的是：
选项：
A. 查找包含指定值元素的算法
B. 插入包含指定值元素的算法
C. 删除第 i（1 ≤ i ≤ n）个元素的算法
D. 获取第 i（1 ≤ i ≤ n）个元素的算法
解析：
A 选项：在顺序存储的有序表中查找包含指定值元素的算法，平均时间复杂度为 O (logn)（例如二分查找），不是 O (1)。
B 选项：插入包含指定值元素的算法，因为可能需要移动元素，平均时间复杂度为 O (n)，不是 O (1)。
C 选项：删除第 i 个元素的算法，同样可能需要移动元素，平均时间复杂度为 O (n)，不是 O (1)。
D 选项：在顺序存储结构中，获取第 i 个元素可以直接通过首地址加上偏移量计算得到，时间复杂度为 O (1)。
答案：D

2 - 27
题目：下述程序段的时间复杂度为（）
python
i = 1
while i <= n:
    i = i * 2
解析：
设循环次数为 t，每次循环 i 变为原来的 2 倍，即 i = 2^t。当 i > n 时，循环结束，此时 2^t > n，可得 t > log₂n。所以时间复杂度为 O (logn)。
答案：A

2 - 28
题目：下述程序段的时间复杂度为（）
python
for i in range(m):
    for j in range(n):
        a[i][j] = 0
解析：
外层循环执行 m 次，内层循环对于外层循环的每一次执行都要执行 n 次，总共执行 m×n 次操作，所以时间复杂度为 O (mn)。
答案：B

2 - 29
题目：下述程序段的时间复杂度为（）
python
m, n = 100, 200
while n > 0:
    c += 1
    if m > 100:
        m -= 10; n -= 1
    else:
        m += 1
解析：
每次循环都会执行 c += 1。
当 m > 100 时，m 每次减 10，n 每次减 1；当 m <= 100 时，m 每次加 1。
由于 m 和 n 的值是固定的（m = 100，n = 200），循环次数是有限的，与输入规模无关，所以时间复杂度为 O (1)。
答案：D

2 - 30
题目：下述程序段的时间复杂度为（）
python
a, b = n, 0
while a >= b * b:
    b += 1
解析：
设循环次数为 t，每次循环 b 加 1，循环结束条件是 a <b * b。b 从 0 开始增加，当 b = √n 时，循环结束，所以循环次数 t 大约为√n，时间复杂度为 O (√n)。
答案：C

2 - 31
题目：下述程序段的时间复杂度为（）
python
for i in range(n - 1):
    for j in range(n - 1 - i):
        a[i], a[j + 1] = a[j + 1], a[i]
解析：
外层循环执行n - 1次。
对于外层循环的第i次执行，内层循环执行n - 1 - i次。
当i = 0时，内层循环执行n - 1次。
当i = 1时，内层循环执行n - 2次。
……
当i = n - 2时，内层循环执行1次。
总的执行次数为(n - 1)+(n - 2)+... + 1，这是一个等差数列求和，根据等差数列求和公式S = n*(n - 1)/2，时间复杂度为O(n²)。
答案：C

2 - 32
题目：以下 Python 程序段的空间复杂度为（）
python
for i in range(n - 1):
    for j in range(n - 1 - i):
        a[i], a[j + 1] = a[j + 1], a[i]
解析：
这段程序中，除了输入的列表a本身，并没有额外的数据结构随着n的增长而增长。
程序只是对列表a中的元素进行交换操作，没有开辟新的与n相关大小的空间。
所以空间复杂度为O(1)。
答案：A

2 - 33
题目：下列关于数据的逻辑结构的叙述中，（）是正确的。
选项：
A. 数据的逻辑结构是数据元素间关系的描述
B. 数据的逻辑结构反映了数据在计算机中的存储方式
C. 数据的逻辑结构分为顺序结构和链式结构
D. 数据的逻辑结构分为静态结构和动态结构
解析：
A 选项：数据的逻辑结构是从逻辑上描述数据元素之间的关系，A 正确。
B 选项：数据的存储方式是存储结构的概念，不是逻辑结构，B 错误。
C 选项：顺序结构和链式结构是存储结构，不是逻辑结构，C 错误。
D 选项：这种分类不属于逻辑结构的常见分类，D 错误。
答案：A

2 - 34
题目：算法的时间复杂度与（）有关。
选项：
A. 问题规模
B. 计算机硬件的运行速度
C. 源程序的长度
D. 编译后执行程序的质量
解析：
A 选项：时间复杂度是衡量算法运行效率与问题规模之间的关系，随着问题规模的增大，算法执行时间的增长趋势，A 正确。
B 选项：计算机硬件运行速度不影响算法本身的时间复杂度，B 错误。
C 选项：源程序长度与算法的时间复杂度无关，C 错误。
D 选项：编译后执行程序的质量与时间复杂度无关，D 错误。
答案：A

2 - 35
题目：数据结构在计算机内存中的表示是指（）。
选项：
A. 数据的存储结构
B. 数据结构
C. 数据的逻辑结构
D. 数据元素之间的关系
解析：
A 选项：数据结构在计算机内存中的表示就是数据的存储结构，它描述了数据在计算机中的存储方式，A 正确。
B 选项：数据结构是一个更宽泛的概念，包括逻辑结构和存储结构等，B 不准确。
C 选项：逻辑结构是从逻辑上描述数据元素之间的关系，不是在内存中的表示，C 错误。
D 选项：数据元素之间的关系是逻辑结构的内容，不是在内存中的表示，D 错误。
答案：A